프로듀서가 전송하려는 메시지들은 프로듀서의 `send()` 메서드를 통해 `시리얼라이저`, `파티셔너`를 거쳐 카프카로 전송된다.   
먼저 파티셔너가 무엇인지부터 살펴보자.   

# 파티셔너 
       
카프카의 토픽은 성능 향상을 위한 병렬 처리가 가능하도록 하기 위해   
**파티션으로 나눈다(최소 하나 또는 둘 이상의 파티션으로 구성)**  
프로듀서가 카프카로 전송한 메시지는 **해당 토픽내 각 파티션의 로그 세그먼트에 저장된다.**    
      
따라서 프로듀서는 토픽으로 메시지를 보낼 때           
**해당 토픽의 어느 파티션으로 메시지를 보내야 할지를 결정 해야하는데 이때 사용하는 것이 파티셔너이다.**           
  
프로듀서가 **파티셔너를 결정하는 디폴트 알고리즘**은       
**메시지의 키를 해시 처리해 파티션을 구하는 방식**을 사용한다.      
따라서 **메시지의 키값이 동일하면 해당 메시지들은 모두 같은 파티션으로 전송된다.**      
    
예상치 못한 많은 양의 메시지가 카프카로 인입되는 경우,         
카프카는 처리량을 높이기 위해 토픽의 파티션을 늘릴 수 있는 기능을 제공한다.         
하지만, **파티션 수가 변경됨과 동시에 메시지의 키와 매핑된 해시 테이블도 변경된다.**     
즉, **동일한 메시지를 보내더라도 다른 파티션으로 전송될 수 있는 문제가 발생한다.**      
  
이렇게 메시지의 키를 이용해 카프카로 메시지를 전송하는 경우,     
관리자의 의도와는 다른 방식으로 메시지 전송이 이뤄질 수 있으므로      
**되도록 파티션 수를 변경하지 않는 것을 추천한다.**   

## 라운드 로빈 전략 
      
프로듀서의 메시지 중 레코드의 **키** 값은 필숫값이 아니므로,          
관리자는 별도의 레코드키값을 지정하지 않고 메시지를 전송할 수 있다.     
    
만약, **키 값을 지정하지 않는다면 키 값은 null이 되고,**.       
기본값인 라운드 로빈 알고리즘을 사용해 **프로듀서는 목적지 토픽의 파티션들로 레코드들을 랜덤으로 전송한다.**.    

[#](#)
  
파티셔너를 거친 후의 레코드들은 배치 처리를 위해 프로듀서의 버퍼 메모리 영역에서 대기한 후 카프카로 전송된다.        
배치 처리를 위해 잠시 메시지들이 대기하는 과정에서 **라운드 로빈 전략은 효율을 떨어뜨릴 수 있다.**        
그 이유는 파티션을 랜덤으로 배치시키기에, 배치 전송을 위한 최소 레코드 수를 충족하지 못하는 상황이 발생할 수 있다.       

물론, 관리자가 특정 시간이 지나면 레코드를 강제로 전송할 수 있도록 설정할 수는 있지만,     
배치와 압축의 효과를 얻지 못한 채 레코드 하나만 카프카로 전송될 수 있으므로 비효율적이다.   

카프카에서는 이와 같은 비효율적인 전송을 보완하기 위해, 스티키 파티셔닝 전략을 공개했다.   

## 스티키 파티셔닝 전략    
   
라운드 로빈 전략에서 지연시간이 불필요하게 증가되는 비효율적인 전송을 개선하고자           
**2019년 출시된 아파치 카프카 2.4 버전부터는 스티키 파티션 전략을 사용하게 된다.**         

[#](#)
       
스티키 파티셔닝이란, **하나의 파티션에 레코드 수를 먼저 채워서 카프카로 빠르게 배치 전송하는 전략을 말한다.**      
이렇듯 스티키 파티셔닝 전략은 라운드 로빈 전략에 비해 분명히 효율적인 전송 방법이다.     
이러한 미묘한 변화가 과연 프로듀서의 성능을 높일지, 굳이 이렇게까지 해야하는 건지 의구심이 들 수 있다.     
하지만, 컨플루언트에 공개한 글에 따르면 스티키 파티셔닝 전략을 적용함으로써         
기본 설정에 비해 약 30% 이상 지연시간이 감소하고 프로듀서의 CPU 사용률도 줄어드는 효과를 얻을 수 있다.      
  
**카프카로 전송하는 메시지의 순서가 그다지 중요하지 않은 경우라면 스트키 파티셔닝 전략을 적용하기를 권장한다.**     

# 메시지 순서가 중요하다면?   

* 하나의 파티션을 잡아서 그쪽에 데이터를 보내는 방식으로해도된다.      
* 하지만, 유지 관리 비용을 따졌을 때, RabbitMq나 ActiveMQ를 쓰는것도 나쁘지 않다.  






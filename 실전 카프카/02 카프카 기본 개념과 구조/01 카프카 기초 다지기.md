# 카프카 기초 다지기   
# 카프카를 구성하는 주요 요소   

* 주키퍼: 카프카의 메타데이터 관리 및 브로커의 정상상태 점검을 담당한다.       
* 카프카 또는 카프카 클러스터: 여러 대의 브로커를 구성한 클러스트를 의미한다.         
* 브로커: 카프카 애플리케이션이 설치된 서버 또는 노드를 말한다.          
* 프로듀서: 카프카로 메시지를 보내는 역할을 하는 클라이언트를 총칭한다.           
* 컨슈머: 카프카에서 메시지를 꺼내가는 역할을 하는 클라이언트를 총칭한다.      
* 토픽: 카프카는 메시지 피드들을 토픽으로 구분하고, 각 토픽의 이름은 카프카 내에서 고유하다.         
* 파티션: 병렬 처리 및 고성능을 얻기 위해 하나의 토픽을 여러 개로 나눈 것을 말한다.     
* 세그먼트: 프로듀서가 전송한 실제 메시지가 브로커의 로컬 디스크에 저장되는 파일을 말한다.     
* 메시지 또는 레코드: 프로듀서가 브로커로 전송하거나 컨슈머가 읽어가는 데이터 조각을 말한다.   

# 리플리케이션   
> 글을 읽기전에 [참고하면 좋을 영상](https://www.youtube.com/watch?v=qpEEoGpWVig&ab_channel=%EB%8D%B0%EB%B8%8C%EC%9B%90%EC%98%81DVWY)
     
리플리케이션이란, **각 메시지들을 여러 개로 복제해서 카프카 클러스터 내 브로커들에 분산시키는 동작을 의미한다.**        
리플리케이션 동작 덕분에, 하나의 브로커가 종료되더라도 카프카는 안전성을 유지할 수 있다.    
  
토픽 생성 명령어 중 replication-factor라는 옵션은 카프카 내 몇 개의 리플리케이션을 유지하겠다는 의미다.     
(토픽이 리플리케이션되는 것이 아니라 토픽의 파티션이 리플리케이션 되는것이다.)     

리플리케이션 팩터 수가 커지면 안정성은 높아지지만, 그만큼 브로커 리소스를 많이 사용하게 된다.     
따라서 복제에 대한 오버헤드를 줄여서 최대한 브로커를 효율적으로 사용하는 것을 권장한다.   
  
토픽 생성시 다음과 같이 기준을 세워두고 리플리케이션 팩터 수를 설정해 사용한다면 더 효율적으로 카프카를 운영할 수 있을 것이다.     
      
* 테스트나 개발 환경: 리플리케이션 팩터 수를 1개로 설정         
* 운영 환경(로그성 메시지로서 약간의 유실 허용): 리플리케이션 팩터 수를 2로 설정       
* 운영 환경(유실 허용하지 않음): 리플리케이션 팩터 수를 3으로 설정     
    
안정성을 높이고자 리플리케이션 팩터 수를 4또는 5 그 이상으로도 설정할 수 있다.       
하지만, **리플리케이션 팩터 수가 3일 경우에 충분히 메시지 안정성도 보장하고 적절한 디스크 공간을 사용할 수 있다.**    
(더 사용하면 디스크를 많이 잡는다는 공수비용을 따지자)   

# 파티션     

하나의 토픽이 한 번에 처리할 수 있는 한계를 높이기 위해       
토픽 하나를 여러개로 나눠서 병렬 처리가 가능하게 만든 것을 파티션이라고 한다.    
하나를 여러개로 나누면 분산 처리도 가능하며 파티션 수 만큼 컨슈머를 연결할 수도 있다.    

![1_O_VK-99FnvVeH7MwQEEhDQ](https://user-images.githubusercontent.com/50267433/148417444-51d80f5d-cb82-42d5-a34b-d89c465ec0b8.png)   
   
카프카 클러스터에 있는 토픽을 파티션으로 나눈 그림이다.(파티션은 0부터 시작한다.)      
파티션 수도 토픽을 생성할 때 옵션으로 설정할 수 있는데, 파티션 수를 정하는 기준은 다소 모호하다.      
각 메시지 크기나 초당 메시지 건수등에 따라 달라지므로 정확하게 예측하기는 어렵다.    
         
특히, 파티션 수는 초기 생성 후 언제든지 늘릴 수 있지만          
반대로 **한 번 늘린 파티션 수는 절대 줄일 수 없다는 특징이 있다.**            
따라서 초기에 토픽을 생성할 때 파티션 수를 작게(2~4) 설정하고        
메시지 처리량이나 컨슈머의 LAG등을 모니터링하면서 조금씩 늘려가는 방법이 가장 좋다.     
(컨슈머의 LAG: 지연 지표로서, 프로듀서가 보낸 메시지 수(카프카에 남은) - 컨슈머가 가져간 메시지 수)       

# 세그먼트  
  
프로듀서를 이용해 카프카의 토픽으로 메시지를 전송하면 컨슈머를 통해 메시지를 읽어 올 수 있다.           
그리고 **카프카에서는 각 메시지들을 저장하는데 메시지는 어디에 저장이 되는 것일까? 🤔**        

```console
[카프카01 서버] cd /data/kafka-logs/
[카프카01 서버] ls
```
```console
__consumer_offsets-0   __consumer_offsets-34

생략,,,

__consumer_offsets-28  __consumer_offsets-9
__consumer_offsets-29  cleaner-offset-checkpoint
__consumer_offsets-3   log-start-offset-checkpoint
__consumer_offsets-30  meta.properties
__consumer_offsets-31  peter-overview01-0
__consumer_offsets-32  recovery-point-offset-checkpoint
__consumer_offsets-33  replication-offset-checkpoint
```
목록을 잘 살펴보면 `peter-overview01-0`디렉토리가 있음을 알 수 있다.    
이는 곧, 하나의 토픽과 파티션에 대한 데이터를 저장하는 것임을 알 수 있다.     

```console
[카프카01 서버] cd peter-overview01-0/
[카프카01 서버] ls
```
```console
00000000000000000000.index  00000000000000000000.timeindex
00000000000000000000.log    leader-epoch-checkpoint
```
그리고 실제로 파일 목록을 살펴보면 위와 같은 데이터들이 있는 것을 알 수 있다.    

```console
[카프카01 서버] xxd 00000000000000000000.log
```
```console
00000000: 0000 0000 0000 0000 0000 0046 0000 0000  ...........F....
00000010: 021b 0d89 3f00 0000 0000 0000 0001 7e1f  ....?.........~.
00000020: ecc2 a000 0001 7e1f ecc2 a0ff ffff ffff  ......~.........
00000030: ffff ffff ffff ffff ff00 0000 0128 0000  .............(..
00000040: 0001 1c20 4669 7273 7420 6d65 7373 6167  ... First messag
00000050: 6500                                     e.
```
특히, `00000000000000000000.log`를 확인해보면 우리가 이전에 보냈던 First message가 들어있다.      
        
즉, 프로듀서를 이용해 보낸 메시지는 토픽의 파티션0에 저장되어 있다.            
이처럼 **프로듀서에 의해 브로커로 전송된 메시지는 토픽의 파티션에 저장되며,**        
**각 메시지들은 세그먼트라는 로그 파일(00000000000000000000.log)의 형태로 브로커의 로컬 디스크에 저장된다.**      

<img width="1694" alt="image" src="https://user-images.githubusercontent.com/50267433/191032712-e82a01c8-df92-4399-a964-e5302885937e.png">
   
각 파티션마다 N개의 세그먼트 로그 파일들이 존재한다.      
세그먼트의 파일 내용을 출력해봄으로써 프로듀서가 전송한 메시지가     
브로커의 로컬 디스크에 안전하게 저장되어 있음을 알 수 있다.    
  
**정리**
1. 프로듀서는 카프카의 peter-overview01 토픽으로 메시지를 전송한다.    
2. peter-overview01 토픽은 파티션이 하나뿐이므로,   
   프로듀서로부터 받은 메시지를 파티션0의 세그먼트 로그 파일에 저장한다.    
3. 브로커의 세그먼트 로그 파일에 저장된 메시지는 컨슈머가 읽어갈 수 있다.  

컨슈머는 peter-overview01 토픽을 컨슘해서 해당 토픽 내 파티션0의 세그먼트 로그 파일에서 메시지를 가져온다.     



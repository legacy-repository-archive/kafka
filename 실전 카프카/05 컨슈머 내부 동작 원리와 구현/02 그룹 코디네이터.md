# 그룹 코디네이터

컨슈머들은 하나의 컨슈머 그룹의 구성원으로 속하며,      
컨슈머 그룹 내의 각 컨슈머들은 서로 자신의 정보를 공유하면서 하나의 공동체로 동작한다.   
   
컨슈머 그룹내의 컨슈머들은 언제든지     
자신이 속한 컨슈머 그룹에서 떠날 수 있으며 새로운 컨슈머가 합류할 수도 있다.      
따라서 컨슈머 그룹은 이러한 변화에 인지하고 각 컨슈머들에게 작업을 균등하게 배분해야한다.  
 
컨슈머 그룹에서 컨슈머들에게 작업을 균등하게 분해하는 동작을     
`컨슈머 리밸런싱`이라고 부르거나 컨슈머 `리밸런싱이 일어났다`라고 말한다.  
  
`정확히 한번 전송`을 관리하기 위한 트랜잭션 코디네이터라는 것이 있었다.         
컨슈머 그룹 역시 안정적인 컨슈머 그룹 관리를 위한 `그룹 코디네이터`가 존재한다.     
   
그룹 코디네이터의 목적은 컨슈머 그룹이 구독한 토픽의 파티션들과 그룹의 멤버들을 트래킹하는 것이다.       
**따라서 파티션 또는 그룹의 멤버에 변화가 생기면, 작업을 균등하게 재 분배하기 위해 컨슈머 리밸런싱 동작이 발생한다.**      
   
그룹 코디네이터는 각 컨슈머 그룹별로 존재하며,     
이러한 그룹 코디네이터는 카프카 클러스터 내의 브로커 중 하나에 위치한다.     
  
[](#)  
      
위 그림은 **`코디네이터`와 `컨슈머`의 관계를 보여주는 구성도이다.**.           
**컨슈머 그룹이 브로커에 최초 연결 요청**을 보내면 **브로커 중 하나에 그룹 코디네이터가 생성되고,**         
이 그룹 코디네이터는 **컨슈머 그룹의 컨슈머 변경과 구독하는 토픽 파티션 변경 등에 대한 감지를 시작한다**       
그리고 **토픽의 파티션과 그룹의 멤버 변경이 일어나면 변경된 내용을 컨슈머들에게 알려주기도 한다.**    

[](#)   

컨슈머 그룹 동작 과정에서 그룹 코디네이터와 컨슈머의 동작 과정은 아래와 같다.     

1. 컨슈머는 컨슈머 설정값 중에서 `bootstrap.brokers` 리스트에 있는 브로커에게      
   컨슈머 클라이언트와 초기 커넥션을 연결하기 위한 요청을 보낸다.      
2. 해당 요청을 받은 브로커는 그룹 코디네이터를 생성하고 컨슈머에게 응답을 보낸다.  
   컨슈머 그룹의 첫 번째 컨슈머가 등록될 때까지 아무 작업도 일어나지 않는다.   
3. 그룹 코디네이터는 `group.initial.rebalance.delay.ms` 의 시간동안 컨슈머의 요청을 기다린다.    
4. 컨슈머는 컨슈머 등록 요청을 그룹 코디네이터에게 보낸다.     
   이때 가장 먼저 요청을 보낸 컨슈머가 컨슈머 그룹의 리더가 된다.    
5. 컨슈머 등록 요청을 받은 그룹 코디네이터는     
   해당 컨슈머 그룹이 구독하는 `토픽`과 `파티션 리스트` 등 리더 컨슈머의 요청에 응담을 보낸다.
6. 리더 컨슈머는 정해진 컨슈머 파티션 할당 전략에 따라   
   **그룹 내 컨슈머들에게 파티션을 할당한 뒤 그룹 코디네이터에게 전달한다.**      
7. 그룹 코디네이터는 해당 정보를 캐시하고 각 그룹 내 컨슈머들에게 성공을 알린다.     
8. 각 컨슈머들은 각자 지정된 토픽 파티션으로부터 메시지들을 가져온다.    
 
우리는 단순하게 `bootstrap.brokers`와 `group.id`만 설정하면       
컨슈머 그룹이 생성되어 카프카로부터 구독한 메시지를 읽어온다고 생각했는데      
실제로는 컨슈머 그룹과 그룹 코디네이터가 서로 긴밀하게 내용을 주고받으며      
**컨슈머 그룹이 안정적으로 메시지를 이어갈 수 있도록 유지하기 위해 노력하는 것이다.**  
   
컨슈머 그룹은 그룹 코디네이터와 연결되어 관리를 받게 된다.        
컨슈머 그룹의 각 컨슈머들은 제외되기도 추가되기도 한다.         
이러한 상태 변경시 그룹 코디네이터에게 join 또는 leave 요청을 보냄으로써 자연스럽게 처리된다.     
**하지만, 컨슈머 장애로 leave 요청을 보내지 못하고 종료되는 경우 그룹 코디네이터는 어떻게 이를 감지할까?**  
 
컨슈머들의 변경 감지를 위해 그룹 코디네이터와 컨슈머들은 서로 **하트비트를 주고 받는다.**       
이렇게 하트비트를 주기적으로 주고 받으면서 그룹 코디네이터는 컨슈머가 살아있는지, 잘 동작하는지를 확인한다.    

|컨슈머 옵션|값|설명|
|--------|--|---|  
|heartbeat.interval.ms|3000|기본값은 3000이며, 그룹 코디네이터와 하트비트 인터벌 시간이다.<br>해당 시간 `session.timeout.ms`보다 낮게 설정해야하며,<br>3분의1이 적절하다.|   
|session.timeout.ms|10000|기본값은 10000이다.<br>어떤 컨슈머가 특정 시간 안에 하트비트를 받지 못한다면<br>문제가 발생했다고 판단해 컨슈머 그룹에서 <br>해당 컨슈머는 제거되고 리밸런싱 동작이 일어난다.|
|max.poll.interval.ms|300000|기본값은 300000 이다.<br>컨슈머는 주기적으로 `poll()`을 호출해 토픽으로부터 레코드들을 가져오는데<br>`poll()` 호출 후 최대 5분간 `poll()` 호출이 없다면<br>컨슈머가 문제가 있는 것으로 판단해 리밸런싱 동작이 일어난다.|  
  
그룹 코디네이터는 방금 살펴본 하트비트 옵션을 통해 컨슈머의 상태를 확인하며,     
특정 컨슈머에 문제가 발생했다고 판단되면 컨슈머 리밸런싱 동작을 통해 컨슈머 그룹의 전체 균형을 다시 맞춘다.    
     
단순하게 하트비트만으로도 컨슈머의 상태를 체크할 수 있지만,     
할당된 파티션에서 컨슈머가 정상적으로 메시지를 가져가고 있는지를     
`Poll()` 동작 여부를 통해 확인하는 등 카프카의 세심하고 상세한 설정을 볼 수 있다.    




